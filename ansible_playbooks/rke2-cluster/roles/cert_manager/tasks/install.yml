---
- name: Check if cert-manager deployment exists
  kubernetes.core.k8s_info:
    kubeconfig: "{{ kubeconfig_path }}"
    kind: Deployment
    namespace: "{{ cert_manager_namespace }}"
    name: cert-manager
  register: cert_manager_deploy

- name: Ensure cert-manager namespace exists with privileged labels
  kubernetes.core.k8s:
    kubeconfig: "{{ kubeconfig_path }}"
    state: present
    definition:
      apiVersion: v1
      kind: Namespace
      metadata:
        name: "{{ cert_manager_namespace }}"
        labels:
          pod-security.kubernetes.io/enforce: privileged
          pod-security.kubernetes.io/audit: privileged
          pod-security.kubernetes.io/warn: privileged

- name: Apply permissive NetworkPolicy for cert-manager
  kubernetes.core.k8s:
    kubeconfig: "{{ kubeconfig_path }}"
    state: present
    definition:
      apiVersion: networking.k8s.io/v1
      kind: NetworkPolicy
      metadata:
        name: cert-manager-allow-all
        namespace: "{{ cert_manager_namespace }}"
      spec:
        podSelector:
          matchLabels:
            app.kubernetes.io/instance: cert-manager
        policyTypes: [Ingress, Egress]
        ingress: [ {} ]
        egress: [ {} ]

- name: Add cert-manager Helm repo
  kubernetes.core.helm_repository:
    name: jetstack
    repo_url: "{{ cert_manager_chart_repo }}"
  when: cert_manager_deploy.resources | length == 0

- name: Install/upgrade cert-manager (CRDs enabled)
  kubernetes.core.helm:
    name: cert-manager
    chart_ref: "{{ cert_manager_chart }}"
    chart_version: "{{ cert_manager_version }}"
    release_namespace: "{{ cert_manager_namespace }}"
    create_namespace: false
    kubeconfig: "{{ kubeconfig_path }}"
    wait: true
    update_repo_cache: true
    values:
      crds:
        enabled: true
  register: cert_manager_helm
  when: cert_manager_deploy.resources | length == 0

- name: Wait for cert-manager CRDs to exist
  kubernetes.core.k8s_info:
    api_version: apiextensions.k8s.io/v1
    kind: CustomResourceDefinition
    kubeconfig: "{{ kubeconfig_path }}"
  register: cert_manager_crds
  until: "'clusterissuers.cert-manager.io' in (cert_manager_crds.resources | map(attribute='metadata.name') | list)"
  retries: 30
  delay: 6
  when: cert_manager_deploy.resources | length == 0

- name: Create ClusterIssuer selfsigned
  kubernetes.core.k8s:
    kubeconfig: "{{ kubeconfig_path }}"
    state: present
    definition:
      apiVersion: cert-manager.io/v1
      kind: ClusterIssuer
      metadata:
        name: selfsigned
      spec:
        selfSigned: {}

- name: Create ClusterIssuer letsencrypt-staging
  kubernetes.core.k8s:
    kubeconfig: "{{ kubeconfig_path }}"
    state: present
    definition:
      apiVersion: cert-manager.io/v1
      kind: ClusterIssuer
      metadata:
        name: letsencrypt-staging
      spec:
        acme:
          email: "{{ cert_manager_acme_email }}"
          server: https://acme-staging-v02.api.letsencrypt.org/directory
          privateKeySecretRef:
            name: letsencrypt-staging-account-key
          solvers:
            - http01:
                ingress:
                  class: "{{ cert_manager_http01_ingress_class }}"

- name: Create ClusterIssuer letsencrypt-prod
  kubernetes.core.k8s:
    kubeconfig: "{{ kubeconfig_path }}"
    state: present
    definition:
      apiVersion: cert-manager.io/v1
      kind: ClusterIssuer
      metadata:
        name: letsencrypt-prod
      spec:
        acme:
          email: "{{ cert_manager_acme_email }}"
          server: https://acme-v02.api.letsencrypt.org/directory
          privateKeySecretRef:
            name: letsencrypt-prod-account-key
          solvers:
            - http01:
                ingress:
                  class: "{{ cert_manager_http01_ingress_class }}"
